<start>        ::= <package> <includes> <parnet_items> | <empty>

<package>   ::= PACKAGE IDENTIFIER | <empty> ;; usually we not defaint for small program or run-able scripts

<includes> ::= <includes> <include> | <empty> ;; It's for third party library; our standard library will was ready automatically for developers. e.g: `math.sin, math.cos, math.tan, ...` 

<include>   ::= USE <identifier_dots>
              | USE STRING

<identifier_dots>  ::= <identifier_dots> "." IDENTIFIER
                     | IDENTIFIER

<parnet_items> ::= <parent_item> <parnet_items>

<parent_item>  ::= <function>
                 | <global_define>

<global_define>  ::= <global_struct>
                   | <global_variable> ;; maybe we allow global variable in some special condition

<global_variable> ::= <datatype> IDENTIFIER 
                    | <datatype> IDENTIFIER "=" <expression_const>

<global_struct>   ::= STRUCT IDENTIFIER "{" <struct_vars> "}"

<struct_vars>    ::= <datatype> IDENTIFIER
                   | <datatype> IDENTIFIER "=" <expression_const>

<function>     ::= <function_prototype> IDENTIFIER <function_arguments> <block>

<function_prototype> ::= <datatype> | <empty> ;; default return type is I32 (int, 32bit) e.g: `main {}` and default return is `return 0`

<function_arguments> ::= <function_arguments> "," <function_argument>

<datatype_primary>   :: = I8
                        | I16
                        | I32
                        | I64
                        | F32
                        | F64
                        | U8
                        | U16
                        | U32
                        | U64
                        | STRING
                        | CHAR ;; it's not c-like character, we can store UTF8 character at this too. (e.g: "ุด")

<datatype>           ::= <datatype_primary>
                       | <datatype_primary> "[" "]"
                       | IDENTIFIER ;; e.g: struct and user defined types

<function_argument>  ::= <datatype> IDENTIFIER

<block>        ::= "{" <statements> "}"

<statements>   ::= <statements> <statement>
                 
<statement>    ::= <statement_return>
                 | <statement_expression>
                 | <statement_if>

                 | <statement_for>
                 | <statement_while>
                 | <statement_dowhile>
                 | <statement_repeat>

                 | <statement_switch>

                 | <statement_print>
                 | <statement_printnl>
                 | <statement_printerr>
                 | <statement_printerrnl>

<statement_repeat>  ::= REPEAT NUMBER <block> ;; for from 0 to j {...}
                      | REPEAT NUMBER TO NUMBER <block> ;; for from i to j {...}

<statement_print>   ::=  "_" <expressions> ;; in c: `printf("%1%2%3",...)`

<statement_printnl> ::=  "__" <expressions> ;; in c: `printf("%1\n%2\n%3\n",...)`

<statement_printerr>::= "!_" <expressions> ;; in c: `fprintf(stderr, "%1%2%3",...)`

<statement_printerrnl>::= "!__" <expressions> ;; in c: `fprintf(stderr, "%1\n%2\n%3\n",...)`

<expressions>    ::= <expressions> "," <expression>
                   | <expression>

<statement_if>   ::= IF <expression> <block>
                   |  IF <expression> <block> ELSE <statement_if>
                   |  IF <expression> <block> ELSE <block>

<statement_switch> ::= SWITCH "{" <switch_cases> "}"

<switch_cases>   ::= <switch_cases> <switch_case>

<switch_case>    ::= CASE <expression_const> ":" <statements>

<statement_for>  ::= FOR <expression> <block>
                   | FOR IDENTIFIER IN <expression_const> <block> ;; e.g in python: `for item in array:`

<statement_while>::= WHILE <expression> <block>

<statement_dowhile>::= DO  <block> while <expression>

<statement_return> ::= RETURN <expressions> ;; we allow returning multi variable in a functions

<expression_const> :== <expression>

<expression>   ::= <term> "+" <expression>
                 | <term>

<term>         ::= <factor> "*" <term>
                 | <factor>

<factor>       ::= "(" <expression> ")"
                 | <const>

<const>        ::= NUMBER | STRING | IDENTIFIER
